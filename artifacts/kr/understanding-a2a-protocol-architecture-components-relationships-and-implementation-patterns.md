# A2A 프로토콜 아키텍처 이해: 컴포넌트, 관계, 그리고 구현 패턴

## A2A는 "Host" 컴포넌트가 없는 단순화된 클라이언트-서버 모델로 작동합니다

Google이 개발한 Agent-to-Agent (A2A) 프로토콜은 **간소화된 2개 컴포넌트 아키텍처**를 구현함으로써 MCP와 같은 다른 프로토콜과 근본적으로 다릅니다: A2A Client와 A2A Server (Remote Agent라고도 함). 이 프로토콜은 **"A2A Host" 컴포넌트를 정의하지 않으며**, 이는 개방형 구현과 분산 에이전트 통신을 강조하는 핵심 아키텍처 결정을 나타냅니다.

A2A Client는 사용자나 시스템을 대신하여 요청을 시작하고 A2A Server의 서비스를 소비합니다. Agent Card (JSON 메타데이터, `/.well-known/agent.json`에 게시됨)를 통해 사용 가능한 에이전트를 발견하고, 작업을 생성 및 관리하며, 인증을 처리하고, Server-Sent Events (SSE)를 통한 스트리밍 업데이트를 포함한 응답을 처리합니다. 클라이언트는 최신 TLS 암호화와 함께 HTTPS를 통한 JSON-RPC 2.0을 사용하여 통신합니다.

A2A Server 또는 Remote Agent는 A2A 프로토콜 메서드를 구현하는 HTTP 엔드포인트를 노출합니다. 자신의 기능과 인증 요구사항을 설명하는 Agent Card를 게시하고, 정의된 생명주기 상태(submitted, working, input-required, completed, failed, canceled)를 통해 들어오는 작업을 처리하며, 출력으로 아티팩트를 생성하고, 동기식 및 스트리밍 통신 패턴을 모두 지원합니다. 서버는 상호작용 전반에 걸쳐 작업 상태를 유지하며 장시간 실행 작업에 대한 푸시 알림을 보낼 수 있습니다.

## 컴포넌트 관계는 유연하고 분산된 아키텍처를 따릅니다

A2A 프로토콜은 배포 패턴에서 놀라운 유연성을 가진 직접적인 클라이언트-서버 통신을 가능하게 합니다. 클라이언트는 Agent Card를 통해 서버를 발견하고, 선언된 스킴(OAuth2, API 키, JWT)을 사용하여 인증하며, 구조화된 작업 요청을 보냅니다. 통신 흐름은 명확한 패턴을 따릅니다: 발견 → 인증 → 작업 시작 → 처리 → 결과 전달.

**주요 상호작용 패턴:**
- **직접 통신**: 클라이언트는 HTTP/JSON-RPC를 사용하여 서버와 직접 통신합니다
- **Peer-to-Peer 기능**: 모든 A2A 서버는 다른 서버에 대한 클라이언트 역할을 할 수 있어 계층적 작업 위임이 가능합니다
- **클라이언트 간 통신 없음**: 클라이언트는 직접 통신하지 않습니다. 모든 상호작용은 서버를 통해 이루어집니다
- **완전 분산**: 컴포넌트는 서로 다른 클라우드 제공업체와 조직에 걸쳐 지리적으로 분산될 수 있습니다

프로토콜은 동기식 요청-응답 패턴(`tasks/send`)과 스트리밍 상호작용(`tasks/sendSubscribe`)을 모두 지원합니다. 스트리밍의 경우, 서버는 실시간 상태 업데이트, 부분 결과 및 진행률 알림을 제공하기 위해 SSE 연결을 유지합니다. 이 아키텍처를 통해 에이전트는 공유 메모리, 도구 또는 공동 배치 없이도 조직 경계를 넘어 협업할 수 있습니다.

## LangGraph 구현은 완전한 A2A 서버 아키텍처를 보여줍니다

지정된 저장소의 LangGraph 기반 에이전트 구현은 프로덕션 준비가 된 패턴을 보여주는 **완전한 A2A 서버 구현**을 제공합니다. 이 통화 변환 에이전트는 우아한 어댑터 패턴을 통해 정교한 LangGraph 에이전트가 A2A 프로토콜과 통합되는 방법을 보여줍니다.

구현은 네 가지 주요 컴포넌트로 구성됩니다. **Agent Implementation**은 Google Gemini LLM과 함께 LangGraph의 ReAct 패턴을 사용하고 체크포인트를 통해 대화 상태를 유지합니다. **Agent Executor**는 중요한 어댑터 레이어 역할을 하며, LangGraph의 실행 모델과 A2A의 작업 지향 접근 방식 간을 변환하고, 동기식 및 스트리밍 응답을 모두 처리합니다. **Server Setup**은 적절한 Agent Card 발견과 함께 Starlette 기반 HTTP 서버를 통해 완전한 A2A 프로토콜 준수를 제공합니다. 마지막으로 **Helper Functions**는 LangGraph의 내부 표현과 A2A 프로토콜 이벤트 간의 변환을 관리합니다.

구현은 LangGraph 개념을 A2A에 우아하게 매핑합니다: LangGraph의 상태 전환은 A2A 작업 상태가 되고, 도구 호출은 스트리밍 상태 업데이트를 생성하며, 최종 결과는 A2A 아티팩트로 변환됩니다. 컨텍스트 보존을 통한 다중 턴 대화를 지원하고, 명확화가 필요할 때 input-required 상태를 보여주며, 처리 중 실시간 업데이트를 제공합니다. 전체 스택은 비차단 실행을 위해 async/await 패턴을 사용하고 적절한 A2A 오류 응답과 함께 강력한 오류 처리를 포함합니다.

## 에이전트는 작업 위임과 서비스 소비를 통해 관계를 맺습니다

A2A 생태계에서 에이전트는 주로 **작업 위임 패턴**을 통해 관계를 설정합니다. 에이전트 구현은 일반적으로 하나 또는 두 가지 역할을 구현합니다: 전문 에이전트에 작업을 위임하는 클라이언트 또는 다른 에이전트에 특정 기능을 제공하는 서버. 이는 전문 에이전트(통화 변환기나 날씨 서비스 등)가 복잡한 워크플로우를 조정하는 오케스트레이터 에이전트에 의해 소비되는 자연스러운 에이전트 네트워크를 생성합니다.

프로토콜은 여러 협업 패턴을 가능하게 합니다. **순차 처리**는 클라이언트가 서버 A에 위임하고, 서버 A는 다시 서버 B에 하위 작업을 위임할 수 있게 합니다. **병렬 처리**는 효율성을 위해 클라이언트가 여러 서버에 동시에 위임할 수 있게 합니다. **계층적 위임**은 어떤 깊이의 에이전트 간 위임도 지원하며, 각 서버는 잠재적으로 다른 서버에 대한 클라이언트 역할을 할 수 있습니다. 이러한 패턴은 서로 다른 에이전트 프레임워크, 공급업체 및 배포 환경에서 원활하게 작동합니다.

에이전트 발견은 기능, 엔드포인트 및 인증 요구사항을 설명하는 "디지털 명함" 역할을 하는 Agent Card를 통해 이루어집니다. 이 발견 메커니즘은 표준 웹 프로토콜과 결합되어 기존 인프라를 수정하지 않고도 새로운 전문 에이전트를 추가할 수 있는 동적 에이전트 생태계를 가능하게 합니다.

## 구현 유연성은 별도 또는 결합된 컴포넌트를 허용합니다

**A2A 준수 에이전트는 프로토콜 컴포넌트를 구현하는 방법에 대해 완전한 자유를 가집니다.** 단일 에이전트에서 모든 역할을 구현해야 한다는 요구사항은 없습니다. 프로토콜은 세 가지 주요 구현 패턴을 지원합니다:

**별도 컴포넌트**는 클라이언트 에이전트, 서버 에이전트 및 사용자 대면 애플리케이션이 완전히 독립적인 가장 유연한 접근 방식을 나타냅니다. 이 패턴은 마이크로서비스 아키텍처에서 뛰어나며 전문화된 팀이 서로 다른 컴포넌트를 개발하고 유지 관리할 수 있게 합니다. 예를 들어, 회사는 오케스트레이션을 위한 클라이언트 에이전트를 개발하면서 전문 작업을 위한 타사 서버 에이전트를 소비할 수 있습니다.

**결합된 구현**은 서비스를 제공하고 다른 에이전트와 조정하는 에이전트에 유용한 단일 에이전트에서 클라이언트 및 서버 기능을 병합합니다. 이 패턴은 완전한 프로토콜 준수를 유지하면서 소규모 시스템의 배포를 단순화합니다. 에이전트는 서버로서 작업을 받으면서 클라이언트로서 하위 작업을 위임할 수 있습니다.

**전문화된 역할**은 에이전트가 필요한 것만 구현할 수 있게 합니다. 날씨 서비스는 서버 역할만 구현할 수 있고, 사용자 대면 오케스트레이터는 주로 클라이언트 역할을 할 수 있습니다. 이러한 유연성은 효율적인 리소스 사용과 명확한 아키텍처 경계를 가능하게 합니다.

## 용어는 아키텍처의 단순성과 유연성을 반영합니다

A2A 프로토콜은 아키텍처 설계를 반영하는 정확한 용어를 사용합니다:

- **A2A 준수 에이전트**: 포함된 컴포넌트에 관계없이 A2A 프로토콜 사양을 구현하는 모든 에이전트
- **A2A Client / 클라이언트 에이전트**: 작업을 시작하고 A2A 서비스를 소비하는 에이전트 또는 애플리케이션
- **A2A Server / Remote agent**: A2A 프로토콜에 따라 작업을 수신하고 처리하는 HTTP 엔드포인트를 노출하는 에이전트
- **Agent Card**: 잘 알려진 URI에서 호스팅되는 에이전트의 기능을 설명하는 JSON 메타데이터 문서

에이전트는 일반적으로 아키텍처 역할보다는 주요 기능(Weather Agent, Translation Agent, Analysis Agent)에 따라 기능적으로 명명됩니다. 이 명명 규칙은 에이전트가 어떻게 구현되었는지보다 무엇을 하는지를 강조하며, 소비자로부터 구현 세부사항을 추상화하려는 프로토콜의 목표를 지원합니다.

"A2A 준수"라는 용어는 특정 구현 패턴을 암시하지 않고 프로토콜 사양에 대한 준수를 나타냅니다. 이 용어는 의도적으로 규범적인 레이블을 피하며, 프로토콜 준수를 통해 상호 운용성을 유지하면서 조직이 에이전트 생태계를 구성하는 방법에 최대한의 유연성을 허용합니다.

## 결론

A2A 프로토콜의 우아한 단순성 - Host-Client-Server 삼위일체가 아닌 Client와 Server 컴포넌트만으로 - 상호 운용 가능한 에이전트 생태계를 구축하는 데 놀라운 유연성을 가능하게 합니다. Host 컴포넌트를 제거하고 직접적인 에이전트 간 통신에 초점을 맞춤으로써, 프로토콜은 엔터프라이즈급 보안과 확장성을 유지하면서 아키텍처 복잡성을 줄입니다. LangGraph 구현은 정교한 에이전트 프레임워크가 A2A와 원활하게 통합될 수 있는 방법을 보여주며, 프로토콜의 단순성이 기능을 제한하는 것이 아니라 명확하고 집중된 설계를 통해 가능하게 한다는 것을 보여줍니다.